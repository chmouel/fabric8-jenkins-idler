// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "auth": Application User Types
//
// Command:
// $ goagen
// --design=github.com/fabric8-services/fabric8-auth/design
// --notool=true
// --out=$(GOPATH)/src/github.com/fabric8-services/fabric8-jenkins-idler/internal/auth
// --pkg=client
// --version=v1.3.1

package client

import (
	"github.com/goadesign/goa"
	uuid "github.com/goadesign/goa/uuid"
	"time"
)

// clusterData user type.
type clusterData struct {
	// API URL
	APIURL *string `form:"api-url,omitempty" json:"api-url,omitempty" xml:"api-url,omitempty"`
	// User application domain name in the cluster
	AppDNS *string `form:"app-dns,omitempty" json:"app-dns,omitempty" xml:"app-dns,omitempty"`
	// Web console URL
	ConsoleURL *string `form:"console-url,omitempty" json:"console-url,omitempty" xml:"console-url,omitempty"`
	// Logging URL
	LoggingURL *string `form:"logging-url,omitempty" json:"logging-url,omitempty" xml:"logging-url,omitempty"`
	// Metrics URL
	MetricsURL *string `form:"metrics-url,omitempty" json:"metrics-url,omitempty" xml:"metrics-url,omitempty"`
	// Cluster name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Validate validates the clusterData type instance.
func (ut *clusterData) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.ConsoleURL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "console-url"))
	}
	if ut.MetricsURL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "metrics-url"))
	}
	if ut.APIURL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "api-url"))
	}
	if ut.LoggingURL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "logging-url"))
	}
	if ut.AppDNS == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "app-dns"))
	}
	return
}

// Publicize creates ClusterData from clusterData
func (ut *clusterData) Publicize() *ClusterData {
	var pub ClusterData
	if ut.APIURL != nil {
		pub.APIURL = *ut.APIURL
	}
	if ut.AppDNS != nil {
		pub.AppDNS = *ut.AppDNS
	}
	if ut.ConsoleURL != nil {
		pub.ConsoleURL = *ut.ConsoleURL
	}
	if ut.LoggingURL != nil {
		pub.LoggingURL = *ut.LoggingURL
	}
	if ut.MetricsURL != nil {
		pub.MetricsURL = *ut.MetricsURL
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	return &pub
}

// ClusterData user type.
type ClusterData struct {
	// API URL
	APIURL string `form:"api-url" json:"api-url" xml:"api-url"`
	// User application domain name in the cluster
	AppDNS string `form:"app-dns" json:"app-dns" xml:"app-dns"`
	// Web console URL
	ConsoleURL string `form:"console-url" json:"console-url" xml:"console-url"`
	// Logging URL
	LoggingURL string `form:"logging-url" json:"logging-url" xml:"logging-url"`
	// Metrics URL
	MetricsURL string `form:"metrics-url" json:"metrics-url" xml:"metrics-url"`
	// Cluster name
	Name string `form:"name" json:"name" xml:"name"`
}

// Validate validates the ClusterData type instance.
func (ut *ClusterData) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.ConsoleURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "console-url"))
	}
	if ut.MetricsURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "metrics-url"))
	}
	if ut.APIURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "api-url"))
	}
	if ut.LoggingURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "logging-url"))
	}
	if ut.AppDNS == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "app-dns"))
	}
	return
}

// createIdentityDataAttributes user type.
type createIdentityDataAttributes struct {
	// Whether the user is approved for using an OpenShift cluster. 'True' is used by default
	Approved *bool `form:"approved,omitempty" json:"approved,omitempty" xml:"approved,omitempty"`
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The OpenShift API URL of the cluster where the user is provisioned to
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty" xml:"cluster,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// Whether email is verified
	EmailVerified *bool `form:"emailVerified,omitempty" json:"emailVerified,omitempty" xml:"emailVerified,omitempty"`
	// Whether the user is enabled
	Enabled *bool `form:"enabled,omitempty" json:"enabled,omitempty" xml:"enabled,omitempty"`
	// The level of features that the user wants to use (for unreleased features)
	FeatureLevel *string `form:"featureLevel,omitempty" json:"featureLevel,omitempty" xml:"featureLevel,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The Red Hat Developers User ID of the user
	RhdUserID *string `form:"rhd_user_id,omitempty" json:"rhd_user_id,omitempty" xml:"rhd_user_id,omitempty"`
	// The associated Red Hat Developers account. If not set then username is used as the RHD username
	RhdUsername *string `form:"rhd_username,omitempty" json:"rhd_username,omitempty" xml:"rhd_username,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Validate validates the createIdentityDataAttributes type instance.
func (ut *createIdentityDataAttributes) Validate() (err error) {
	if ut.Username == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "username"))
	}
	if ut.Email == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "email"))
	}
	if ut.Cluster == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "cluster"))
	}
	if ut.RhdUserID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "rhd_user_id"))
	}
	return
}

// Publicize creates CreateIdentityDataAttributes from createIdentityDataAttributes
func (ut *createIdentityDataAttributes) Publicize() *CreateIdentityDataAttributes {
	var pub CreateIdentityDataAttributes
	if ut.Approved != nil {
		pub.Approved = ut.Approved
	}
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Cluster != nil {
		pub.Cluster = *ut.Cluster
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.Email != nil {
		pub.Email = *ut.Email
	}
	if ut.EmailVerified != nil {
		pub.EmailVerified = ut.EmailVerified
	}
	if ut.Enabled != nil {
		pub.Enabled = ut.Enabled
	}
	if ut.FeatureLevel != nil {
		pub.FeatureLevel = ut.FeatureLevel
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.RhdUserID != nil {
		pub.RhdUserID = *ut.RhdUserID
	}
	if ut.RhdUsername != nil {
		pub.RhdUsername = ut.RhdUsername
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.Username != nil {
		pub.Username = *ut.Username
	}
	return &pub
}

// CreateIdentityDataAttributes user type.
type CreateIdentityDataAttributes struct {
	// Whether the user is approved for using an OpenShift cluster. 'True' is used by default
	Approved *bool `form:"approved,omitempty" json:"approved,omitempty" xml:"approved,omitempty"`
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The OpenShift API URL of the cluster where the user is provisioned to
	Cluster string `form:"cluster" json:"cluster" xml:"cluster"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email string `form:"email" json:"email" xml:"email"`
	// Whether email is verified
	EmailVerified *bool `form:"emailVerified,omitempty" json:"emailVerified,omitempty" xml:"emailVerified,omitempty"`
	// Whether the user is enabled
	Enabled *bool `form:"enabled,omitempty" json:"enabled,omitempty" xml:"enabled,omitempty"`
	// The level of features that the user wants to use (for unreleased features)
	FeatureLevel *string `form:"featureLevel,omitempty" json:"featureLevel,omitempty" xml:"featureLevel,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The Red Hat Developers User ID of the user
	RhdUserID string `form:"rhd_user_id" json:"rhd_user_id" xml:"rhd_user_id"`
	// The associated Red Hat Developers account. If not set then username is used as the RHD username
	RhdUsername *string `form:"rhd_username,omitempty" json:"rhd_username,omitempty" xml:"rhd_username,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username string `form:"username" json:"username" xml:"username"`
}

// Validate validates the CreateIdentityDataAttributes type instance.
func (ut *CreateIdentityDataAttributes) Validate() (err error) {
	if ut.Username == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "username"))
	}
	if ut.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "email"))
	}
	if ut.Cluster == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "cluster"))
	}
	if ut.RhdUserID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "rhd_user_id"))
	}
	return
}

// createUserData user type.
type createUserData struct {
	// Attributes of the user identity
	Attributes *createIdentityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the createUserData type instance.
func (ut *createUserData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateUserData from createUserData
func (ut *createUserData) Publicize() *CreateUserData {
	var pub CreateUserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// CreateUserData user type.
type CreateUserData struct {
	// Attributes of the user identity
	Attributes *CreateIdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the CreateUserData type instance.
func (ut *CreateUserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// identityData user type.
type identityData struct {
	// Attributes of the user identity
	Attributes *identityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user identity
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the identityData type instance.
func (ut *identityData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	return
}

// Publicize creates IdentityData from identityData
func (ut *identityData) Publicize() *IdentityData {
	var pub IdentityData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// IdentityData user type.
type IdentityData struct {
	// Attributes of the user identity
	Attributes *IdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user identity
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the IdentityData type instance.
func (ut *IdentityData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	return
}

// identityDataAttributes user type.
type identityDataAttributes struct {
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates IdentityDataAttributes from identityDataAttributes
func (ut *identityDataAttributes) Publicize() *IdentityDataAttributes {
	var pub IdentityDataAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// IdentityDataAttributes user type.
type IdentityDataAttributes struct {
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// organizationData user type.
type organizationData struct {
	// unique id for the organization
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// flag indicating whether the user is a member of the organization
	Member *bool `form:"member,omitempty" json:"member,omitempty" xml:"member,omitempty"`
	// name of the organization
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// roles assigned to the user for the organization
	Roles []string `form:"roles,omitempty" json:"roles,omitempty" xml:"roles,omitempty"`
}

// Validate validates the organizationData type instance.
func (ut *organizationData) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Member == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "member"))
	}
	if ut.Roles == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "roles"))
	}
	return
}

// Publicize creates OrganizationData from organizationData
func (ut *organizationData) Publicize() *OrganizationData {
	var pub OrganizationData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Member != nil {
		pub.Member = *ut.Member
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.Roles != nil {
		pub.Roles = ut.Roles
	}
	return &pub
}

// OrganizationData user type.
type OrganizationData struct {
	// unique id for the organization
	ID string `form:"id" json:"id" xml:"id"`
	// flag indicating whether the user is a member of the organization
	Member bool `form:"member" json:"member" xml:"member"`
	// name of the organization
	Name string `form:"name" json:"name" xml:"name"`
	// roles assigned to the user for the organization
	Roles []string `form:"roles" json:"roles" xml:"roles"`
}

// Validate validates the OrganizationData type instance.
func (ut *OrganizationData) Validate() (err error) {
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}

	if ut.Roles == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "roles"))
	}
	return
}

// refreshToken user type.
type refreshToken struct {
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// Publicize creates RefreshToken from refreshToken
func (ut *refreshToken) Publicize() *RefreshToken {
	var pub RefreshToken
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	return &pub
}

// RefreshToken user type.
type RefreshToken struct {
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// space user type.
type space struct {
	// ID of the space
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Publicize creates Space from space
func (ut *space) Publicize() *Space {
	var pub Space
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	return &pub
}

// Space user type.
type Space struct {
	// ID of the space
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// spaceResourceData user type.
type spaceResourceData struct {
	// Keycloak Permission ID associated with this Space
	PermissionID *string `form:"permissionID,omitempty" json:"permissionID,omitempty" xml:"permissionID,omitempty"`
	// Keycloak Policy ID associated with this Space
	PolicyID *string `form:"policyID,omitempty" json:"policyID,omitempty" xml:"policyID,omitempty"`
	// Keycloak Resource ID associated with this Space
	ResourceID *string `form:"resourceID,omitempty" json:"resourceID,omitempty" xml:"resourceID,omitempty"`
}

// Validate validates the spaceResourceData type instance.
func (ut *spaceResourceData) Validate() (err error) {
	if ut.ResourceID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "resourceID"))
	}
	if ut.PermissionID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "permissionID"))
	}
	if ut.PolicyID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "policyID"))
	}
	return
}

// Publicize creates SpaceResourceData from spaceResourceData
func (ut *spaceResourceData) Publicize() *SpaceResourceData {
	var pub SpaceResourceData
	if ut.PermissionID != nil {
		pub.PermissionID = *ut.PermissionID
	}
	if ut.PolicyID != nil {
		pub.PolicyID = *ut.PolicyID
	}
	if ut.ResourceID != nil {
		pub.ResourceID = *ut.ResourceID
	}
	return &pub
}

// SpaceResourceData user type.
type SpaceResourceData struct {
	// Keycloak Permission ID associated with this Space
	PermissionID string `form:"permissionID" json:"permissionID" xml:"permissionID"`
	// Keycloak Policy ID associated with this Space
	PolicyID string `form:"policyID" json:"policyID" xml:"policyID"`
	// Keycloak Resource ID associated with this Space
	ResourceID string `form:"resourceID" json:"resourceID" xml:"resourceID"`
}

// Validate validates the SpaceResourceData type instance.
func (ut *SpaceResourceData) Validate() (err error) {
	if ut.ResourceID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "resourceID"))
	}
	if ut.PermissionID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "permissionID"))
	}
	if ut.PolicyID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "policyID"))
	}
	return
}

// tokenData user type.
type tokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn *interface{} `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// Token is not valid if issued before this date
	NotBeforePolicy *interface{} `form:"not-before-policy,omitempty" json:"not-before-policy,omitempty" xml:"not-before-policy,omitempty"`
	// Refresh token expires in seconds
	RefreshExpiresIn *interface{} `form:"refresh_expires_in,omitempty" json:"refresh_expires_in,omitempty" xml:"refresh_expires_in,omitempty"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the tokenData type instance.
func (ut *tokenData) Validate() (err error) {
	if ut.ExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "expires_in"))
	}
	if ut.RefreshExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "refresh_expires_in"))
	}
	if ut.NotBeforePolicy == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "not-before-policy"))
	}
	return
}

// Publicize creates TokenData from tokenData
func (ut *tokenData) Publicize() *TokenData {
	var pub TokenData
	if ut.AccessToken != nil {
		pub.AccessToken = ut.AccessToken
	}
	if ut.ExpiresIn != nil {
		pub.ExpiresIn = *ut.ExpiresIn
	}
	if ut.NotBeforePolicy != nil {
		pub.NotBeforePolicy = *ut.NotBeforePolicy
	}
	if ut.RefreshExpiresIn != nil {
		pub.RefreshExpiresIn = *ut.RefreshExpiresIn
	}
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	if ut.TokenType != nil {
		pub.TokenType = ut.TokenType
	}
	return &pub
}

// TokenData user type.
type TokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn interface{} `form:"expires_in" json:"expires_in" xml:"expires_in"`
	// Token is not valid if issued before this date
	NotBeforePolicy interface{} `form:"not-before-policy" json:"not-before-policy" xml:"not-before-policy"`
	// Refresh token expires in seconds
	RefreshExpiresIn interface{} `form:"refresh_expires_in" json:"refresh_expires_in" xml:"refresh_expires_in"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the TokenData type instance.
func (ut *TokenData) Validate() (err error) {

	return
}

// tokenExchange user type.
type tokenExchange struct {
	// Service Account ID. Used to obtain a PAT for this service account.
	ClientID *string `form:"client_id,omitempty" json:"client_id,omitempty" xml:"client_id,omitempty"`
	// Service Account secret. Used to obtain a PAT for this service account.
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty" xml:"client_secret,omitempty"`
	// this is the authorization_code you received from /api/authorize endpoint
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Grant type. If set to "client_credentials" then this token exchange request is for a Protection API Token (PAT). PAT can be used to authenticate the corresponding Service Account. If the Grant Type is "authorization_code" we can use a authorization_code to get access_token
	GrantType *string `form:"grant_type,omitempty" json:"grant_type,omitempty" xml:"grant_type,omitempty"`
	// Must be identical to the redirect URI provided while getting the authorization_code
	RedirectURI *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty"`
	// Refresh Token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// Validate validates the tokenExchange type instance.
func (ut *tokenExchange) Validate() (err error) {
	if ut.GrantType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "grant_type"))
	}
	if ut.ClientID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "client_id"))
	}
	if ut.GrantType != nil {
		if !(*ut.GrantType == "client_credentials" || *ut.GrantType == "authorization_code" || *ut.GrantType == "refresh_token") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.grant_type`, *ut.GrantType, []interface{}{"client_credentials", "authorization_code", "refresh_token"}))
		}
	}
	return
}

// Publicize creates TokenExchange from tokenExchange
func (ut *tokenExchange) Publicize() *TokenExchange {
	var pub TokenExchange
	if ut.ClientID != nil {
		pub.ClientID = *ut.ClientID
	}
	if ut.ClientSecret != nil {
		pub.ClientSecret = ut.ClientSecret
	}
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.GrantType != nil {
		pub.GrantType = *ut.GrantType
	}
	if ut.RedirectURI != nil {
		pub.RedirectURI = ut.RedirectURI
	}
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	return &pub
}

// TokenExchange user type.
type TokenExchange struct {
	// Service Account ID. Used to obtain a PAT for this service account.
	ClientID string `form:"client_id" json:"client_id" xml:"client_id"`
	// Service Account secret. Used to obtain a PAT for this service account.
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty" xml:"client_secret,omitempty"`
	// this is the authorization_code you received from /api/authorize endpoint
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Grant type. If set to "client_credentials" then this token exchange request is for a Protection API Token (PAT). PAT can be used to authenticate the corresponding Service Account. If the Grant Type is "authorization_code" we can use a authorization_code to get access_token
	GrantType string `form:"grant_type" json:"grant_type" xml:"grant_type"`
	// Must be identical to the redirect URI provided while getting the authorization_code
	RedirectURI *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty" xml:"redirect_uri,omitempty"`
	// Refresh Token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// Validate validates the TokenExchange type instance.
func (ut *TokenExchange) Validate() (err error) {
	if ut.GrantType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "grant_type"))
	}
	if ut.ClientID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "client_id"))
	}
	if !(ut.GrantType == "client_credentials" || ut.GrantType == "authorization_code" || ut.GrantType == "refresh_token") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.grant_type`, ut.GrantType, []interface{}{"client_credentials", "authorization_code", "refresh_token"}))
	}
	return
}

// updateIdentityDataAttributes user type.
type updateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// Whether the identity has been deprovisioned
	Deprovisioned *bool `form:"deprovisioned,omitempty" json:"deprovisioned,omitempty" xml:"deprovisioned,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// Whether the email address would be private.
	EmailPrivate *bool `form:"emailPrivate,omitempty" json:"emailPrivate,omitempty" xml:"emailPrivate,omitempty"`
	// The level of features that the user wants to use (for unreleased features)
	FeatureLevel *string `form:"featureLevel,omitempty" json:"featureLevel,omitempty" xml:"featureLevel,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UpdateIdentityDataAttributes from updateIdentityDataAttributes
func (ut *updateIdentityDataAttributes) Publicize() *UpdateIdentityDataAttributes {
	var pub UpdateIdentityDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.Deprovisioned != nil {
		pub.Deprovisioned = ut.Deprovisioned
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.EmailPrivate != nil {
		pub.EmailPrivate = ut.EmailPrivate
	}
	if ut.FeatureLevel != nil {
		pub.FeatureLevel = ut.FeatureLevel
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UpdateIdentityDataAttributes user type.
type UpdateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// Whether the identity has been deprovisioned
	Deprovisioned *bool `form:"deprovisioned,omitempty" json:"deprovisioned,omitempty" xml:"deprovisioned,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// Whether the email address would be private.
	EmailPrivate *bool `form:"emailPrivate,omitempty" json:"emailPrivate,omitempty" xml:"emailPrivate,omitempty"`
	// The level of features that the user wants to use (for unreleased features)
	FeatureLevel *string `form:"featureLevel,omitempty" json:"featureLevel,omitempty" xml:"featureLevel,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// updateUserData user type.
type updateUserData struct {
	// Attributes of the user identity
	Attributes *updateIdentityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserData type instance.
func (ut *updateUserData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	return
}

// Publicize creates UpdateUserData from updateUserData
func (ut *updateUserData) Publicize() *UpdateUserData {
	var pub UpdateUserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UpdateUserData user type.
type UpdateUserData struct {
	// Attributes of the user identity
	Attributes *UpdateIdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserData type instance.
func (ut *UpdateUserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	return
}

// JSONAPI store for the data of a user identity ID. See also http://jsonapi.org/format/#document-resource-object
type updateUserID struct {
	// user identity ID
	ID   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserID type instance.
func (ut *updateUserID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "identities") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"identities"}))
		}
	}
	return
}

// Publicize creates UpdateUserID from updateUserID
func (ut *updateUserID) Publicize() *UpdateUserID {
	var pub UpdateUserID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a user identity ID. See also http://jsonapi.org/format/#document-resource-object
type UpdateUserID struct {
	// user identity ID
	ID   string `form:"id" json:"id" xml:"id"`
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserID type instance.
func (ut *UpdateUserID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if !(ut.Type == "identities") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"identities"}))
	}
	return
}

// userData user type.
type userData struct {
	// Attributes of the user
	Attributes *userDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userData type instance.
func (ut *userData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	return
}

// Publicize creates UserData from userData
func (ut *userData) Publicize() *UserData {
	var pub UserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UserData user type.
type UserData struct {
	// Attributes of the user
	Attributes *UserDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserData type instance.
func (ut *UserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	return
}

// userDataAttributes user type.
type userDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The OpenShift API URL of the cluster where the user is provisioned to
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty" xml:"cluster,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// Whether the email address would be private.
	EmailPrivate *bool `form:"emailPrivate,omitempty" json:"emailPrivate,omitempty" xml:"emailPrivate,omitempty"`
	// Whether the email is a verified one
	EmailVerified *bool `form:"emailVerified,omitempty" json:"emailVerified,omitempty" xml:"emailVerified,omitempty"`
	// The level of features that the user wants to use (for unreleased features)
	FeatureLevel *string `form:"featureLevel,omitempty" json:"featureLevel,omitempty" xml:"featureLevel,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UserDataAttributes from userDataAttributes
func (ut *userDataAttributes) Publicize() *UserDataAttributes {
	var pub UserDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Cluster != nil {
		pub.Cluster = ut.Cluster
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.EmailPrivate != nil {
		pub.EmailPrivate = ut.EmailPrivate
	}
	if ut.EmailVerified != nil {
		pub.EmailVerified = ut.EmailVerified
	}
	if ut.FeatureLevel != nil {
		pub.FeatureLevel = ut.FeatureLevel
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.IdentityID != nil {
		pub.IdentityID = ut.IdentityID
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.UserID != nil {
		pub.UserID = ut.UserID
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UserDataAttributes user type.
type UserDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The OpenShift API URL of the cluster where the user is provisioned to
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty" xml:"cluster,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// Whether the email address would be private.
	EmailPrivate *bool `form:"emailPrivate,omitempty" json:"emailPrivate,omitempty" xml:"emailPrivate,omitempty"`
	// Whether the email is a verified one
	EmailVerified *bool `form:"emailVerified,omitempty" json:"emailVerified,omitempty" xml:"emailVerified,omitempty"`
	// The level of features that the user wants to use (for unreleased features)
	FeatureLevel *string `form:"featureLevel,omitempty" json:"featureLevel,omitempty" xml:"featureLevel,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// userListMeta user type.
type userListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the userListMeta type instance.
func (ut *userListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates UserListMeta from userListMeta
func (ut *userListMeta) Publicize() *UserListMeta {
	var pub UserListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// UserListMeta user type.
type UserListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// identityRolesData user type.
type identityRolesData struct {
	// The ID of the assignee
	AssigneeID *string `form:"assignee_id,omitempty" json:"assignee_id,omitempty" xml:"assignee_id,omitempty"`
	// The type of assignee, example: user,group,team
	AssigneeType *string `form:"assignee_type,omitempty" json:"assignee_type,omitempty" xml:"assignee_type,omitempty"`
	Inherited    *bool   `form:"inherited,omitempty" json:"inherited,omitempty" xml:"inherited,omitempty"`
	// The ID of the resource from this role was inherited
	InheritedFrom *string `form:"inherited_from,omitempty" json:"inherited_from,omitempty" xml:"inherited_from,omitempty"`
	// The name of the role
	RoleName *string `form:"role_name,omitempty" json:"role_name,omitempty" xml:"role_name,omitempty"`
}

// Validate validates the identityRolesData type instance.
func (ut *identityRolesData) Validate() (err error) {
	if ut.RoleName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "role_name"))
	}
	if ut.AssigneeID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "assignee_id"))
	}
	if ut.AssigneeType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "assignee_type"))
	}
	if ut.Inherited == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "inherited"))
	}
	return
}

// Publicize creates IdentityRolesData from identityRolesData
func (ut *identityRolesData) Publicize() *IdentityRolesData {
	var pub IdentityRolesData
	if ut.AssigneeID != nil {
		pub.AssigneeID = *ut.AssigneeID
	}
	if ut.AssigneeType != nil {
		pub.AssigneeType = *ut.AssigneeType
	}
	if ut.Inherited != nil {
		pub.Inherited = *ut.Inherited
	}
	if ut.InheritedFrom != nil {
		pub.InheritedFrom = ut.InheritedFrom
	}
	if ut.RoleName != nil {
		pub.RoleName = *ut.RoleName
	}
	return &pub
}

// IdentityRolesData user type.
type IdentityRolesData struct {
	// The ID of the assignee
	AssigneeID string `form:"assignee_id" json:"assignee_id" xml:"assignee_id"`
	// The type of assignee, example: user,group,team
	AssigneeType string `form:"assignee_type" json:"assignee_type" xml:"assignee_type"`
	Inherited    bool   `form:"inherited" json:"inherited" xml:"inherited"`
	// The ID of the resource from this role was inherited
	InheritedFrom *string `form:"inherited_from,omitempty" json:"inherited_from,omitempty" xml:"inherited_from,omitempty"`
	// The name of the role
	RoleName string `form:"role_name" json:"role_name" xml:"role_name"`
}

// Validate validates the IdentityRolesData type instance.
func (ut *IdentityRolesData) Validate() (err error) {
	if ut.RoleName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "role_name"))
	}
	if ut.AssigneeID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "assignee_id"))
	}
	if ut.AssigneeType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "assignee_type"))
	}

	return
}

// pagingLinks user type.
type pagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// Publicize creates PagingLinks from pagingLinks
func (ut *pagingLinks) Publicize() *PagingLinks {
	var pub PagingLinks
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.First != nil {
		pub.First = ut.First
	}
	if ut.Last != nil {
		pub.Last = ut.Last
	}
	if ut.Next != nil {
		pub.Next = ut.Next
	}
	if ut.Prev != nil {
		pub.Prev = ut.Prev
	}
	return &pub
}

// PagingLinks user type.
type PagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}
